def solution(number, k):
    answer = ''
    # 원본 변조를 피하기 위해 다른 변수에 카피해서 조작
    k_copy = k
    # 최종적으로 결과 값을 담아낼 스택
    bigger = []
    
    for num in number:
        num = int(num)
        
        # 스택에 숫자가 존재하고, 제거 횟수가 남아있고, 스택의 마지막 숫자가 현재 순회 숫자보다 작은 동안 계속 스택을 pop하고 제거 횟수를 1 감소시킨다.
        while len(bigger) > 0 and k_copy > 0 and bigger[-1] < num:
            bigger.pop()
            k_copy -= 1
        
        # while이 끝나고 현재 순회 숫자를 스택에 추가한다.
        # 두 구문의 의미를 요약하면, 우선 number의 모든 숫자를 for로 순회한다. 각 숫자에 대해, 스택의 마지막 숫자부터 비교해서 자신보다 작은 것들을 모두 pop하여 제거하고 자신을 스택에 추가한다. 이 과정 자체가 그리디이다.
        # 각 순회 단계의 숫자에 대해, 지금까지 쌓아 만든 숫자 스택에 대해, 자신이 특정 자릿수의 숫자를 대신해서 들어가려면, 원본 숫자들의 배치 순서를 그대로 지켜야하므로 원래 있던 숫자를 제거하고 자신이 들어가야만 한다.
        bigger.append(num)
    
    # number = 97865, k = 1인 경우를 생각해보자.
    # 그럼 stack에는 9865가 들어가있고 k는 1이 남아있다.
    # 이렇듯, 마지막 즈음에서 비교하려는 숫자 쌍이 내림차순으로 이미 잘 배치되어있다면 원래 있던 숫자를 제거하지 않고 자신을 스택에 추가하게 된다.
    # 이런 경우, 뒤에서 k만큼의 숫자를 그냥 빼버리고 출력해주면 된다. 뒤에서 k만큼의 숫자들이 while 로직에 따라 내림차순으로 되어있기 때문에 그대로 빼줘버리면 되는 것이다.
    if k_copy != 0:
        bigger = bigger[:-k_copy]
        
    answer = "".join(map(str, bigger))

    return answer